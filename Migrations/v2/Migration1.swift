#!/usr/bin/swift

import Foundation

// Input generated by:
// SELECT fileUUID, appMetaData, mimeType FROM FileIndex WHERE fileGroupUUID IS NULL INTO OUTFILE '/Users/chris/output.sql' FIELDS TERMINATED BY ',' ENCLOSED BY "'"  LINES TERMINATED BY '\n';

// Example input lines:
// '24471557-6723-48CB-9C16-0ED58E02E5D6','{"title": "Christopher G. Prince"}','image/jpeg'
// '5162154B-737C-46AB-AD89-EB35CB75CF6B','{"fileType":"discussion"}','text/plain'
// 'A64A21C5-1CB8-4BD3-A6C4-DD3118EDB5BD','{"fileType":"image","discussionUUID":"5162154B-737C-46AB-AD89-EB35CB75CF6B","title":"Christopher G. Prince"}','image/jpeg'

struct AppMetaData: Codable {
    let title: String?
    let fileType: String?
    let discussionUUID: UUID?
    
    var onlyTitle: Bool {
        title != nil && fileType == nil && discussionUUID == nil
    }
    
    var discussionFileType: Bool {
        title == nil && fileType == "discussion" && discussionUUID == nil
    }
    
    var imageFileType: Bool {
        fileType == "image" && discussionUUID != nil
    }
}

class ProcessMigrations {
    let decoder = JSONDecoder()
    let imageMimeType = "image/jpeg"
    let imageObjectType = "image"
    let imageFileLabel = "image"
    let commentFileLabel = "comments"
    let changeResolverName = "CommentFile"
    
    func writeUpdate(fileGroupUUID: UUID, fileLabel: String, changeResolverName: String? = nil, fileUUID: UUID) {
        var changeResolver = ""
        if let changeResolverName = changeResolverName {
            changeResolver = ", changeResolverName = '\(changeResolverName)'"
        }
        
        let update = "UPDATE FileIndex SET fileGroupUUID = '\(fileGroupUUID.uuidString)', objectType = '\(imageObjectType)', fileLabel = '\(fileLabel)'\(changeResolver) WHERE fileUUID = '\(fileUUID.uuidString)';"
        print("\(update)")
    }
    
    // Process data from FileIndex where the fileGroupUUID is NULL.
    func doFileIndex() throws {
        var count = 0
        while let str = readLine() {
            count += 1
            let line = str.split(separator: "'")
                .filter {$0 != ","}
            guard line.count == 3 else {
                fatalError("Not exactly three items on a line: \(count): \(str)")
            }
            
            guard let fileUUID = UUID(uuidString: String(line[0])) else {
                fatalError("Could not get fileUUID: \(count): \(str)")
            }
            
            guard let dataForAppMetaData = String(line[1]).data(using: .utf8) else {
                fatalError("Could not convert to data: \(count): \(str)")
            }
            
            let appMetaData = try decoder.decode(AppMetaData.self, from: dataForAppMetaData)
            
            let mimeType = String(line[2])
            
            if appMetaData.onlyTitle {
                guard mimeType == imageMimeType else {
                    fatalError("Did not get imageMimeType: \(count): \(str)")
                }
                
                // Generate a UUID for a fileGroupUUID, and add both objectType and fileLabel
                
                let newFileGroupUUID = UUID()
                writeUpdate(fileGroupUUID: newFileGroupUUID, fileLabel: imageFileLabel, fileUUID: fileUUID)
            }
            else if appMetaData.discussionFileType {
                // Skip; Waiting for `imageFileType`
            }
            else if appMetaData.imageFileType,
                let discussionUUID = appMetaData.discussionUUID {

                let newFileGroupUUID = UUID()
                
                writeUpdate(fileGroupUUID: newFileGroupUUID, fileLabel: commentFileLabel, changeResolverName: changeResolverName, fileUUID: discussionUUID)
                writeUpdate(fileGroupUUID: newFileGroupUUID, fileLabel: imageFileLabel, fileUUID: fileUUID)
            }
            else {
                fatalError("Bad data: \(count): \(str)")
            }
        
            // print("line: \(uuid), mimeType: \(mimeType)")
        }
    }
}

do {
    try ProcessMigrations().doFileIndex()
} catch let error {
    print("Error: \(error)")
}
