//
//  AppleSignInCreds+Refresh.swift
//  Server
//
//  Created by Christopher G Prince on 10/4/19.
//

import Foundation
import HeliumLogger
import LoggerAPI
import KituraNet
import ServerAccount

extension AppleSignInCreds {
    struct GenerateRefreshTokenResult: Decodable {
        // The purpose of this, for Apple, is undefined.
        let access_token: String
        
        let refresh_token: String
        let expires_in: Date
        let id_token: String
        let token_type: String
    }
    
    struct RefreshIdTokenResult: Decodable {
        let access_token: String
        let token_type: String
        let expires_in: Date
    }
    
    // https://developer.apple.com/documentation/signinwithapplerestapi/generate_and_validate_tokens
    
    /// This can only be called once for a serverAuthCode.
    func generateRefreshToken(serverAuthCode: String, completion: @escaping (Swift.Error?) -> ()) {
        // https://stackoverflow.com/questions/4007969/application-x-www-form-urlencoded-or-multipart-form-data
        // For application/x-www-form-urlencoded, the body of the HTTP message sent to the server is essentially one giant query string -- name/value pairs are separated by the ampersand (&), and names are separated from values by the equals symbol (=). An example of this would be:
        // MyVariableOne=ValueOne&MyVariableTwo=ValueTwo
        
        /*
        client_id
        string
        (Required) (Authorization and Validation) The application identifier for your app.
        Content-Type: text/plain
        
        client_secret
        string
        (Required) (Authorization and Validation) A secret generated as a JSON Web Token that uses the secret key generated by the WWDR portal.
        Content-Type: text/plain
        
        code
        string
        (Authorization) The authorization code received from your applicationâ€™s user agent. The code is single use only and valid for five minutes.
        Content-Type: text/plain
        
        grant_type
        string
        (Required) (Authorization and Validation) The grant type that determines how the client interacts with the server. For authorization code validation, use authorization_code. For refresh token validation requests, use refresh_token.
        Content-Type: text/plain
        
        refresh_token
        string
        (Validation) The refresh token received during the authorization request.
        Content-Type: text/plain
        
        redirect_uri
        string
        (Authorization) The destination URI the code was originally sent to.
        Content-Type: text/plain
         */
         
        guard let clientSecret = createClientSecret() else {
            completion(AppleSignInCredsError.failedCreatingClientSecret)
            return
        }
        
        // What to use for the redirect_uri?
        // Looks like I have to create a Service ID, which I've been avoiding until now.
        // "You will have to use the value you passed to the "Return URL" field ... on the same Service ID."
        // See https://auth0.com/blog/what-is-sign-in-with-apple-a-new-identity-provider/
        // And https://developer.apple.com/account/resources/identifiers/list/serviceId
        // When I was creatting the Service Id, I got the message "An App ID with Identifier '' is not available. Please enter a different string"
        // The problem was that I was making a test app, and used "test" as part of the bundle Id (see also https://stackoverflow.com/questions/20565565/an-app-id-with-identifier-is-not-available-please-enter-a-different-string)
        // Hmmm. It seems that this can not be the same as the app id for the iOS app that is using the server.
        let redirectURI = config.redirectURI
        
        let bodyParameters = "client_id=\(config.clientId)" + "&" +
            "client_secret=\(clientSecret)" + "&" +
            "code=\(serverAuthCode)" + "&" +
            "grant_type=authorization_code" + "&" +
            "redirect_uri=\(redirectURI)"
        Log.debug("bodyParameters: \(bodyParameters)")
        
        let additionalHeaders = ["Content-Type": "application/x-www-form-urlencoded"]

        apiCall(method: "POST", path: "/auth/token", additionalHeaders:additionalHeaders, body: .string(bodyParameters), expectedSuccessBody: .data) {[weak self] apiResult, statusCode, responseHeaders in
            guard let self = self else {
                completion(GenerateTokensError.couldNotGetSelf)
                return
            }
            
            guard statusCode == HTTPStatusCode.OK else {
                completion(GenerateTokensError.badStatusCode(statusCode))
                return
            }
            
            guard apiResult != nil else {
                completion(GenerateTokensError.nilAPIResult)
                return
            }
            
            guard case .data(let data) = apiResult else {
                completion(GenerateTokensError.noDataInAPIResult)
                return
            }
            
            let decoder = JSONDecoder()
            let tokenResult: GenerateRefreshTokenResult
            do {
                tokenResult = try decoder.decode(GenerateRefreshTokenResult.self, from: data)
            } catch let error {
                Log.error("\(error)")
                completion(GenerateTokensError.couldNotDecodeResult)
                return
            }
            
            self.accessToken = tokenResult.id_token
            self.refreshToken = tokenResult.refresh_token

            Log.debug("Obtained tokens: idToken: \(String(describing: self.accessToken))\n refreshToken: \(String(describing: self.refreshToken))")
            
            guard let delegate = self.delegate else {
                Log.warning("No delegate!")
                completion(nil)
                return
            }
            
            guard delegate.saveToDatabase(account: self) else {
                completion(GenerateTokensError.errorSavingCredsToDatabase)
                return
            }

            completion(nil)
        }
    }
    
    /// Validate the given refresh token. This does *not* generate a new id token-- the API returns an updated *access token*, which Apple doesn't define a use for (and we don't save).
    /// On success, updates the lastRefreshTokenValidation.
    func validateRefreshToken(refreshToken: String, completion: @escaping (Swift.Error?) -> ()) {
        self.refreshToken = refreshToken
        
        guard let clientSecret = createClientSecret() else {
            completion(AppleSignInCredsError.failedCreatingClientSecret)
            return
        }
                
        let bodyParameters = "client_id=\(config.clientId)" + "&" +
            "client_secret=\(clientSecret)" + "&" +
            "refresh_token=\(refreshToken)" + "&" +
            "grant_type=refresh_token"
            
        Log.debug("bodyParameters: \(bodyParameters)")
        
        let additionalHeaders = ["Content-Type": "application/x-www-form-urlencoded"]

        apiCall(method: "POST", path: "/auth/token", additionalHeaders:additionalHeaders, body: .string(bodyParameters), expectedSuccessBody: .data) {[weak self] apiResult, statusCode, responseHeaders in
            guard let self = self else {
                completion(GenerateTokensError.couldNotGetSelf)
                return
            }
            
            guard statusCode == HTTPStatusCode.OK else {
                completion(GenerateTokensError.badStatusCode(statusCode))
                return
            }
            
            guard apiResult != nil else {
                completion(GenerateTokensError.nilAPIResult)
                return
            }
            
            guard case .data(let data) = apiResult else {
                completion(GenerateTokensError.noDataInAPIResult)
                return
            }
            
            let decoder = JSONDecoder()
            do {
                _ = try decoder.decode(RefreshIdTokenResult.self, from: data)
            } catch let error {
                Log.error("\(error)")
                completion(GenerateTokensError.couldNotDecodeResult)
                return
            }
            
            self.lastRefreshTokenValidation = Date()
            
            guard let delegate = self.delegate else {
                Log.warning("No delegate!")
                completion(nil)
                return
            }
            
            guard delegate.saveToDatabase(account: self) else {
                completion(GenerateTokensError.errorSavingCredsToDatabase)
                return
            }

            completion(nil)
        }
    }
}
